# coding: utf-8

"""
    localhost:8088

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 4.0.2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ChannelsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def channels_channel_id_answer_post(self, channel_id, **kwargs):  # noqa: E501
        """Answer a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_answer_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_answer_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_answer_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_answer_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Answer a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_answer_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_answer_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_answer_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/answer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_continue_post(self, channel_id, **kwargs):  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_continue_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str context: The context to continue to.
        :param str extension: The extension to continue to.
        :param int priority: The priority to continue to.
        :param str label: The label to continue to - will supersede 'priority' if both are provided.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_continue_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_continue_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_continue_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_continue_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str context: The context to continue to.
        :param str extension: The extension to continue to.
        :param int priority: The priority to continue to.
        :param str label: The label to continue to - will supersede 'priority' if both are provided.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'context', 'extension', 'priority', 'label']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_continue_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_continue_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'context' in params:
            query_params.append(('context', params['context']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'label' in params:
            query_params.append(('label', params['label']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/continue', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_delete(self, channel_id, **kwargs):  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str reason: Reason for hanging up the channel
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str reason: Reason for hanging up the channel
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_dial_post(self, channel_id, **kwargs):  # noqa: E501
        """Dial a created channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_dial_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str caller: Channel ID of caller
        :param int timeout: Dial timeout
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_dial_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_dial_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_dial_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Dial a created channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_dial_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str caller: Channel ID of caller
        :param int timeout: Dial timeout
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'caller', 'timeout']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_dial_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_dial_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'caller' in params:
            query_params.append(('caller', params['caller']))  # noqa: E501
        if 'timeout' in params:
            query_params.append(('timeout', params['timeout']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/dial', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_dtmf_post(self, channel_id, **kwargs):  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_dtmf_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str dtmf: DTMF To send.
        :param int before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :param int between: Amount of time in between DTMF digits (specified in milliseconds).
        :param int duration: Length of each DTMF digit (specified in milliseconds).
        :param int after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_dtmf_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_dtmf_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_dtmf_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_dtmf_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str dtmf: DTMF To send.
        :param int before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :param int between: Amount of time in between DTMF digits (specified in milliseconds).
        :param int duration: Length of each DTMF digit (specified in milliseconds).
        :param int after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'dtmf', 'before', 'between', 'duration', 'after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_dtmf_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_dtmf_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'dtmf' in params:
            query_params.append(('dtmf', params['dtmf']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'between' in params:
            query_params.append(('between', params['between']))  # noqa: E501
        if 'duration' in params:
            query_params.append(('duration', params['duration']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/dtmf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_get(self, channel_id, **kwargs):  # noqa: E501
        """Channel details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_get(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_get_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_get_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_get_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Channel details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_get_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_hold_delete(self, channel_id, **kwargs):  # noqa: E501
        """Remove a channel from hold.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_hold_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_hold_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_hold_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_hold_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Remove a channel from hold.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_hold_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_hold_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_hold_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/hold', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_hold_post(self, channel_id, **kwargs):  # noqa: E501
        """Hold a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_hold_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_hold_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_hold_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_hold_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Hold a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_hold_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_hold_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_hold_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/hold', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_moh_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_moh_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_moh_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_moh_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_moh_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_moh_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_moh_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_moh_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/moh', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_moh_post(self, channel_id, **kwargs):  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_moh_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str moh_class: Music on hold class to use
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_moh_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_moh_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_moh_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_moh_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str moh_class: Music on hold class to use
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'moh_class']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_moh_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_moh_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'moh_class' in params:
            query_params.append(('mohClass', params['moh_class']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/moh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_move_post(self, channel_id, app, **kwargs):  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_move_post(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str app: The channel will be passed to this Stasis application. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_move_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_move_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_move_post_with_http_info(self, channel_id, app, **kwargs):  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_move_post_with_http_info(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str app: The channel will be passed to this Stasis application. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'app', 'x_asterisk_id', 'app_args']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_move_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_move_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `channels_channel_id_move_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_mute_delete(self, channel_id, **kwargs):  # noqa: E501
        """Unmute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_mute_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str direction: Direction in which to unmute audio
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_mute_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_mute_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_mute_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Unmute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_mute_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str direction: Direction in which to unmute audio
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_mute_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_mute_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/mute', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_mute_post(self, channel_id, **kwargs):  # noqa: E501
        """Mute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_mute_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str direction: Direction in which to mute audio
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_mute_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_mute_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_mute_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Mute a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_mute_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str direction: Direction in which to mute audio
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_mute_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_mute_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/mute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_play_playback_id_post(self, channel_id, playback_id, media, **kwargs):  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_play_playback_id_post(channel_id, playback_id, media, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str playback_id: Playback ID. (required)
        :param list[str] media: Media URIs to play. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str lang: For sounds, selects language for sound.
        :param int offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :param int skipms: Number of milliseconds to skip for forward/reverse operations.
        :return: Playback
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_play_playback_id_post_with_http_info(channel_id, playback_id, media, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_play_playback_id_post_with_http_info(channel_id, playback_id, media, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_play_playback_id_post_with_http_info(self, channel_id, playback_id, media, **kwargs):  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_play_playback_id_post_with_http_info(channel_id, playback_id, media, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str playback_id: Playback ID. (required)
        :param list[str] media: Media URIs to play. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str lang: For sounds, selects language for sound.
        :param int offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :param int skipms: Number of milliseconds to skip for forward/reverse operations.
        :return: Playback
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'playback_id', 'media', 'x_asterisk_id', 'lang', 'offsetms', 'skipms']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_play_playback_id_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501
        # verify the required parameter 'playback_id' is set
        if ('playback_id' not in params or
                params['playback_id'] is None):
            raise ValueError("Missing the required parameter `playback_id` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501
        # verify the required parameter 'media' is set
        if ('media' not in params or
                params['media'] is None):
            raise ValueError("Missing the required parameter `media` when calling `channels_channel_id_play_playback_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501
        if 'playback_id' in params:
            path_params['playbackId'] = params['playback_id']  # noqa: E501

        query_params = []
        if 'media' in params:
            query_params.append(('media', params['media']))  # noqa: E501
            collection_formats['media'] = 'csv'  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'offsetms' in params:
            query_params.append(('offsetms', params['offsetms']))  # noqa: E501
        if 'skipms' in params:
            query_params.append(('skipms', params['skipms']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/play/{playbackId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Playback',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_play_post(self, channel_id, media, **kwargs):  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_play_post(channel_id, media, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param list[str] media: Media URIs to play. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str lang: For sounds, selects language for sound.
        :param int offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :param int skipms: Number of milliseconds to skip for forward/reverse operations.
        :param str playback_id: Playback ID.
        :return: Playback
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_play_post_with_http_info(channel_id, media, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_play_post_with_http_info(channel_id, media, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_play_post_with_http_info(self, channel_id, media, **kwargs):  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_play_post_with_http_info(channel_id, media, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param list[str] media: Media URIs to play. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str lang: For sounds, selects language for sound.
        :param int offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :param int skipms: Number of milliseconds to skip for forward/reverse operations.
        :param str playback_id: Playback ID.
        :return: Playback
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'media', 'x_asterisk_id', 'lang', 'offsetms', 'skipms', 'playback_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_play_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_play_post`")  # noqa: E501
        # verify the required parameter 'media' is set
        if ('media' not in params or
                params['media'] is None):
            raise ValueError("Missing the required parameter `media` when calling `channels_channel_id_play_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'media' in params:
            query_params.append(('media', params['media']))  # noqa: E501
            collection_formats['media'] = 'csv'  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'offsetms' in params:
            query_params.append(('offsetms', params['offsetms']))  # noqa: E501
        if 'skipms' in params:
            query_params.append(('skipms', params['skipms']))  # noqa: E501
        if 'playback_id' in params:
            query_params.append(('playbackId', params['playback_id']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/play', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Playback',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_post(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_post(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: The unique id to assign the channel on creation. (required)
        :param str endpoint: Endpoint to call. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :param str context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :param int priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :param str label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :param str app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str caller_id: CallerID to use when dialing the endpoint or extension.
        :param int timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: The unique id of the channel which is originating this one.
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_post_with_http_info(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_post_with_http_info(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: The unique id to assign the channel on creation. (required)
        :param str endpoint: Endpoint to call. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :param str context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :param int priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :param str label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :param str app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str caller_id: CallerID to use when dialing the endpoint or extension.
        :param int timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: The unique id of the channel which is originating this one.
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'endpoint', 'x_asterisk_id', 'extension', 'context', 'priority', 'label', 'app', 'app_args', 'caller_id', 'timeout', 'variables', 'other_channel_id', 'originator', 'formats']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_post`")  # noqa: E501
        # verify the required parameter 'endpoint' is set
        if ('endpoint' not in params or
                params['endpoint'] is None):
            raise ValueError("Missing the required parameter `endpoint` when calling `channels_channel_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'endpoint' in params:
            query_params.append(('endpoint', params['endpoint']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'context' in params:
            query_params.append(('context', params['context']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'label' in params:
            query_params.append(('label', params['label']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501
        if 'caller_id' in params:
            query_params.append(('callerId', params['caller_id']))  # noqa: E501
        if 'timeout' in params:
            query_params.append(('timeout', params['timeout']))  # noqa: E501
        if 'other_channel_id' in params:
            query_params.append(('otherChannelId', params['other_channel_id']))  # noqa: E501
        if 'originator' in params:
            query_params.append(('originator', params['originator']))  # noqa: E501
        if 'formats' in params:
            query_params.append(('formats', params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'variables' in params:
            body_params = params['variables']
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_record_post(self, channel_id, name, format, **kwargs):  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_record_post(channel_id, name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str name: Recording's filename (required)
        :param str format: Format to encode audio in (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param int max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :param int max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :param str if_exists: Action to take if a recording with the same name already exists.
        :param bool beep: Play beep when recording begins
        :param str terminate_on: DTMF input to terminate recording
        :return: LiveRecording
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_record_post_with_http_info(channel_id, name, format, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_record_post_with_http_info(channel_id, name, format, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_record_post_with_http_info(self, channel_id, name, format, **kwargs):  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_record_post_with_http_info(channel_id, name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str name: Recording's filename (required)
        :param str format: Format to encode audio in (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param int max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :param int max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :param str if_exists: Action to take if a recording with the same name already exists.
        :param bool beep: Play beep when recording begins
        :param str terminate_on: DTMF input to terminate recording
        :return: LiveRecording
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'name', 'format', 'x_asterisk_id', 'max_duration_seconds', 'max_silence_seconds', 'if_exists', 'beep', 'terminate_on']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_record_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_record_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `channels_channel_id_record_post`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `channels_channel_id_record_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'max_duration_seconds' in params:
            query_params.append(('maxDurationSeconds', params['max_duration_seconds']))  # noqa: E501
        if 'max_silence_seconds' in params:
            query_params.append(('maxSilenceSeconds', params['max_silence_seconds']))  # noqa: E501
        if 'if_exists' in params:
            query_params.append(('ifExists', params['if_exists']))  # noqa: E501
        if 'beep' in params:
            query_params.append(('beep', params['beep']))  # noqa: E501
        if 'terminate_on' in params:
            query_params.append(('terminateOn', params['terminate_on']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/record', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LiveRecording',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_redirect_post(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_redirect_post(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str endpoint: The endpoint to redirect the channel to (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_redirect_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_redirect_post_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_redirect_post_with_http_info(self, channel_id, endpoint, **kwargs):  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_redirect_post_with_http_info(channel_id, endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str endpoint: The endpoint to redirect the channel to (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'endpoint', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_redirect_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_redirect_post`")  # noqa: E501
        # verify the required parameter 'endpoint' is set
        if ('endpoint' not in params or
                params['endpoint'] is None):
            raise ValueError("Missing the required parameter `endpoint` when calling `channels_channel_id_redirect_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'endpoint' in params:
            query_params.append(('endpoint', params['endpoint']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/redirect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_ring_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_ring_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_ring_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_ring_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_ring_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_ring_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_ring_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_ring_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/ring', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_ring_post(self, channel_id, **kwargs):  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_ring_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_ring_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_ring_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_ring_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_ring_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_ring_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_ring_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/ring', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_rtp_statistics_get(self, channel_id, **kwargs):  # noqa: E501
        """RTP stats on a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_rtp_statistics_get(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: RTPstat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_rtp_statistics_get_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_rtp_statistics_get_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_rtp_statistics_get_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """RTP stats on a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_rtp_statistics_get_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: RTPstat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_rtp_statistics_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_rtp_statistics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/rtp_statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RTPstat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_silence_delete(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_silence_delete(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_silence_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_silence_delete_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_silence_delete_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_silence_delete_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_silence_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_silence_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/silence', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_silence_post(self, channel_id, **kwargs):  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_silence_post(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_silence_post_with_http_info(channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_silence_post_with_http_info(channel_id, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_silence_post_with_http_info(self, channel_id, **kwargs):  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_silence_post_with_http_info(channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_silence_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_silence_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/silence', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_snoop_post(self, channel_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_snoop_post(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str app: Application the snooping channel is placed into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str spy: Direction of audio to spy on
        :param str whisper: Direction of audio to whisper into
        :param str app_args: The application arguments to pass to the Stasis application
        :param str snoop_id: Unique ID to assign to snooping channel
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_snoop_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_snoop_post_with_http_info(channel_id, app, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_snoop_post_with_http_info(self, channel_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_snoop_post_with_http_info(channel_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str app: Application the snooping channel is placed into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str spy: Direction of audio to spy on
        :param str whisper: Direction of audio to whisper into
        :param str app_args: The application arguments to pass to the Stasis application
        :param str snoop_id: Unique ID to assign to snooping channel
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'app', 'x_asterisk_id', 'spy', 'whisper', 'app_args', 'snoop_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_snoop_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_snoop_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `channels_channel_id_snoop_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'spy' in params:
            query_params.append(('spy', params['spy']))  # noqa: E501
        if 'whisper' in params:
            query_params.append(('whisper', params['whisper']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501
        if 'snoop_id' in params:
            query_params.append(('snoopId', params['snoop_id']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/snoop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_snoop_snoop_id_post(self, channel_id, snoop_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_snoop_snoop_id_post(channel_id, snoop_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str snoop_id: Unique ID to assign to snooping channel (required)
        :param str app: Application the snooping channel is placed into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str spy: Direction of audio to spy on
        :param str whisper: Direction of audio to whisper into
        :param str app_args: The application arguments to pass to the Stasis application
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_snoop_snoop_id_post_with_http_info(channel_id, snoop_id, app, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_snoop_snoop_id_post_with_http_info(channel_id, snoop_id, app, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_snoop_snoop_id_post_with_http_info(self, channel_id, snoop_id, app, **kwargs):  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_snoop_snoop_id_post_with_http_info(channel_id, snoop_id, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str snoop_id: Unique ID to assign to snooping channel (required)
        :param str app: Application the snooping channel is placed into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str spy: Direction of audio to spy on
        :param str whisper: Direction of audio to whisper into
        :param str app_args: The application arguments to pass to the Stasis application
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'snoop_id', 'app', 'x_asterisk_id', 'spy', 'whisper', 'app_args']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_snoop_snoop_id_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501
        # verify the required parameter 'snoop_id' is set
        if ('snoop_id' not in params or
                params['snoop_id'] is None):
            raise ValueError("Missing the required parameter `snoop_id` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `channels_channel_id_snoop_snoop_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501
        if 'snoop_id' in params:
            path_params['snoopId'] = params['snoop_id']  # noqa: E501

        query_params = []
        if 'spy' in params:
            query_params.append(('spy', params['spy']))  # noqa: E501
        if 'whisper' in params:
            query_params.append(('whisper', params['whisper']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/snoop/{snoopId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_variable_get(self, channel_id, variable, **kwargs):  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_variable_get(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str variable: The channel variable or function to get (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: Variable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_variable_get_with_http_info(channel_id, variable, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_variable_get_with_http_info(channel_id, variable, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_variable_get_with_http_info(self, channel_id, variable, **kwargs):  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_variable_get_with_http_info(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str variable: The channel variable or function to get (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: Variable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'variable', 'x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_variable_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_variable_get`")  # noqa: E501
        # verify the required parameter 'variable' is set
        if ('variable' not in params or
                params['variable'] is None):
            raise ValueError("Missing the required parameter `variable` when calling `channels_channel_id_variable_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'variable' in params:
            query_params.append(('variable', params['variable']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/variable', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Variable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_channel_id_variable_post(self, channel_id, variable, **kwargs):  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_variable_post(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str variable: The channel variable or function to set (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str value: The value to set the variable to
        :param bool bypass_stasis: Set the variable even if the channel is not in Stasis application
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_channel_id_variable_post_with_http_info(channel_id, variable, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_channel_id_variable_post_with_http_info(channel_id, variable, **kwargs)  # noqa: E501
            return data

    def channels_channel_id_variable_post_with_http_info(self, channel_id, variable, **kwargs):  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_channel_id_variable_post_with_http_info(channel_id, variable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channel_id: Channel's id (required)
        :param str variable: The channel variable or function to set (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str value: The value to set the variable to
        :param bool bypass_stasis: Set the variable even if the channel is not in Stasis application
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channel_id', 'variable', 'x_asterisk_id', 'value', 'bypass_stasis']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_channel_id_variable_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params or
                params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `channels_channel_id_variable_post`")  # noqa: E501
        # verify the required parameter 'variable' is set
        if ('variable' not in params or
                params['variable'] is None):
            raise ValueError("Missing the required parameter `variable` when calling `channels_channel_id_variable_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']  # noqa: E501

        query_params = []
        if 'variable' in params:
            query_params.append(('variable', params['variable']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'bypass_stasis' in params:
            query_params.append(('bypassStasis', params['bypass_stasis']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelId}/variable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_create_post(self, endpoint, app, **kwargs):  # noqa: E501
        """Create channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_create_post(endpoint, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint: Endpoint for channel communication (required)
        :param str app: Stasis Application to place channel into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str channel_id: The unique id to assign the channel on creation.
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: Unique ID of the calling channel
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_create_post_with_http_info(endpoint, app, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_create_post_with_http_info(endpoint, app, **kwargs)  # noqa: E501
            return data

    def channels_create_post_with_http_info(self, endpoint, app, **kwargs):  # noqa: E501
        """Create channel.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_create_post_with_http_info(endpoint, app, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint: Endpoint for channel communication (required)
        :param str app: Stasis Application to place channel into (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str channel_id: The unique id to assign the channel on creation.
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: Unique ID of the calling channel
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['endpoint', 'app', 'x_asterisk_id', 'app_args', 'channel_id', 'other_channel_id', 'originator', 'formats']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_create_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'endpoint' is set
        if ('endpoint' not in params or
                params['endpoint'] is None):
            raise ValueError("Missing the required parameter `endpoint` when calling `channels_create_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `channels_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'endpoint' in params:
            query_params.append(('endpoint', params['endpoint']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501
        if 'channel_id' in params:
            query_params.append(('channelId', params['channel_id']))  # noqa: E501
        if 'other_channel_id' in params:
            query_params.append(('otherChannelId', params['other_channel_id']))  # noqa: E501
        if 'originator' in params:
            query_params.append(('originator', params['originator']))  # noqa: E501
        if 'formats' in params:
            query_params.append(('formats', params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_external_media_post(self, app, external_host, format, **kwargs):  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_external_media_post(app, external_host, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app: Stasis Application to place channel into (required)
        :param str external_host: Hostname/ip:port of external host (required)
        :param str format: Format to encode audio in (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str channel_id: The unique id to assign the channel on creation.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str encapsulation: Payload encapsulation protocol
        :param str transport: Transport protocol
        :param str connection_type: Connection type (client/server)
        :param str direction: External media direction
        :return: ExternalMedia
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_external_media_post_with_http_info(app, external_host, format, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_external_media_post_with_http_info(app, external_host, format, **kwargs)  # noqa: E501
            return data

    def channels_external_media_post_with_http_info(self, app, external_host, format, **kwargs):  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_external_media_post_with_http_info(app, external_host, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app: Stasis Application to place channel into (required)
        :param str external_host: Hostname/ip:port of external host (required)
        :param str format: Format to encode audio in (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str channel_id: The unique id to assign the channel on creation.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str encapsulation: Payload encapsulation protocol
        :param str transport: Transport protocol
        :param str connection_type: Connection type (client/server)
        :param str direction: External media direction
        :return: ExternalMedia
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app', 'external_host', 'format', 'x_asterisk_id', 'channel_id', 'variables', 'encapsulation', 'transport', 'connection_type', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_external_media_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `channels_external_media_post`")  # noqa: E501
        # verify the required parameter 'external_host' is set
        if ('external_host' not in params or
                params['external_host'] is None):
            raise ValueError("Missing the required parameter `external_host` when calling `channels_external_media_post`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `channels_external_media_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'channel_id' in params:
            query_params.append(('channelId', params['channel_id']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'external_host' in params:
            query_params.append(('external_host', params['external_host']))  # noqa: E501
        if 'encapsulation' in params:
            query_params.append(('encapsulation', params['encapsulation']))  # noqa: E501
        if 'transport' in params:
            query_params.append(('transport', params['transport']))  # noqa: E501
        if 'connection_type' in params:
            query_params.append(('connection_type', params['connection_type']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'variables' in params:
            body_params = params['variables']
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels/externalMedia', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExternalMedia',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_get(self, **kwargs):  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: list[Channel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.channels_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def channels_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :return: list[Channel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_asterisk_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Channel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_post(self, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_post(endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint: Endpoint to call. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :param str context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :param int priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :param str label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :param str app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str caller_id: CallerID to use when dialing the endpoint or extension.
        :param int timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str channel_id: The unique id to assign the channel on creation.
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: The unique id of the channel which is originating this one.
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_post_with_http_info(endpoint, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_post_with_http_info(endpoint, **kwargs)  # noqa: E501
            return data

    def channels_post_with_http_info(self, endpoint, **kwargs):  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_post_with_http_info(endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str endpoint: Endpoint to call. (required)
        :param str x_asterisk_id: Asterisk ID used to route the request through the API Gateway
        :param str extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :param str context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :param int priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :param str label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :param str app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :param str caller_id: CallerID to use when dialing the endpoint or extension.
        :param int timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :param list[ConfigTuple] variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :param str channel_id: The unique id to assign the channel on creation.
        :param str other_channel_id: The unique id to assign the second channel when using local channels.
        :param str originator: The unique id of the channel which is originating this one.
        :param str formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['endpoint', 'x_asterisk_id', 'extension', 'context', 'priority', 'label', 'app', 'app_args', 'caller_id', 'timeout', 'variables', 'channel_id', 'other_channel_id', 'originator', 'formats']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'endpoint' is set
        if ('endpoint' not in params or
                params['endpoint'] is None):
            raise ValueError("Missing the required parameter `endpoint` when calling `channels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'endpoint' in params:
            query_params.append(('endpoint', params['endpoint']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'context' in params:
            query_params.append(('context', params['context']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'label' in params:
            query_params.append(('label', params['label']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'app_args' in params:
            query_params.append(('appArgs', params['app_args']))  # noqa: E501
        if 'caller_id' in params:
            query_params.append(('callerId', params['caller_id']))  # noqa: E501
        if 'timeout' in params:
            query_params.append(('timeout', params['timeout']))  # noqa: E501
        if 'channel_id' in params:
            query_params.append(('channelId', params['channel_id']))  # noqa: E501
        if 'other_channel_id' in params:
            query_params.append(('otherChannelId', params['other_channel_id']))  # noqa: E501
        if 'originator' in params:
            query_params.append(('originator', params['originator']))  # noqa: E501
        if 'formats' in params:
            query_params.append(('formats', params['formats']))  # noqa: E501

        header_params = {}
        if 'x_asterisk_id' in params:
            header_params['X-Asterisk-ID'] = params['x_asterisk_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'variables' in params:
            body_params = params['variables']
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/channels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
